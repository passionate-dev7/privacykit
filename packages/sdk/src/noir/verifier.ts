/**
 * Noir Verifier
 *
 * Handles local and on-chain verification of Groth16 proofs generated by the Noir prover.
 * Supports both off-chain verification (for testing) and on-chain verification via Solana programs.
 */

import { BarretenbergBackend } from '@noir-lang/backend_barretenberg';
import {
  Connection,
  PublicKey,
  Transaction,
  TransactionInstruction,
  SystemProgram,
  Keypair,
} from '@solana/web3.js';
import { NoirCompiler, CompiledCircuitArtifact, CompiledCircuit } from './compiler';
import { ProofResult } from './prover';
import { Logger, defaultLogger } from '../utils/logger';
import { ProofVerificationError } from '../utils/errors';
import type { WalletAdapter } from '../types';

/**
 * Verification result
 */
export interface VerificationResult {
  /** Whether the proof is valid */
  valid: boolean;
  /** Circuit name that was verified */
  circuitName: string;
  /** Verification time in milliseconds */
  verificationTimeMs: number;
  /** For on-chain verification, the transaction signature */
  signature?: string;
  /** Any error message if verification failed */
  error?: string;
}

/**
 * On-chain verifier configuration
 */
export interface OnChainVerifierConfig {
  /** Solana connection */
  connection: Connection;
  /** Wallet for signing transactions */
  wallet: WalletAdapter;
  /** Custom verifier program ID (defaults to Sunspot) */
  verifierProgramId?: PublicKey;
}

/**
 * Sunspot Groth16 Verifier Program ID
 * This is the production verifier deployed by Reilabs
 */
export const SUNSPOT_VERIFIER_PROGRAM_ID = new PublicKey(
  'SunspotVerifier111111111111111111111111111'
);

/**
 * Instruction codes for the Sunspot verifier
 */
enum SunspotInstruction {
  /** Initialize a verification key account */
  InitVerificationKey = 0,
  /** Verify a proof against a stored verification key */
  VerifyProof = 1,
  /** Verify a proof with inline verification key */
  VerifyProofInline = 2,
}

/**
 * NoirVerifier class for verifying ZK proofs
 */
export class NoirVerifier {
  private compiler: NoirCompiler;
  private backends: Map<string, BarretenbergBackend> = new Map();
  private logger: Logger;

  constructor(compiler?: NoirCompiler, logger?: Logger) {
    this.compiler = compiler || new NoirCompiler();
    this.logger = (logger || defaultLogger).child('NoirVerifier');
  }

  /**
   * Initialize the verifier for a circuit
   */
  async initialize(circuitName: string, circuit?: CompiledCircuit): Promise<void> {
    this.logger.info(`Initializing verifier for circuit: ${circuitName}`);

    try {
      let artifact: CompiledCircuitArtifact;
      if (circuit) {
        artifact = await this.compiler.loadFromArtifact(circuitName, circuit);
      } else {
        artifact = await this.compiler.loadCompiledCircuit(circuitName);
      }

      const backend = new BarretenbergBackend(artifact.circuit);
      this.backends.set(circuitName, backend);

      this.logger.info(`Verifier initialized for ${circuitName}`);
    } catch (error) {
      this.logger.error(`Failed to initialize verifier for ${circuitName}`, error);
      throw error;
    }
  }

  /**
   * Check if verifier is initialized for a circuit
   */
  isInitialized(circuitName: string): boolean {
    return this.backends.has(circuitName);
  }

  /**
   * Verify a proof locally (off-chain)
   */
  async verifyLocal(proofResult: ProofResult): Promise<VerificationResult> {
    const { circuitName, proof, publicInputs } = proofResult;

    if (!this.isInitialized(circuitName)) {
      throw new Error(
        `Verifier not initialized for circuit: ${circuitName}. Call initialize() first.`
      );
    }

    this.logger.info(`Verifying proof locally for circuit: ${circuitName}`);
    const startTime = Date.now();

    try {
      const backend = this.backends.get(circuitName)!;

      // Verify the proof using Barretenberg
      const isValid = await backend.verifyProof({
        proof,
        publicInputs,
      });

      const verificationTime = Date.now() - startTime;

      const result: VerificationResult = {
        valid: isValid,
        circuitName,
        verificationTimeMs: verificationTime,
      };

      this.logger.info(
        `Local verification ${isValid ? 'passed' : 'failed'} for ${circuitName} in ${verificationTime}ms`
      );

      return result;
    } catch (error) {
      this.logger.error(`Local verification failed for ${circuitName}`, error);
      return {
        valid: false,
        circuitName,
        verificationTimeMs: Date.now() - startTime,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  /**
   * Verify a proof on-chain using Solana
   */
  async verifyOnChain(
    proofResult: ProofResult,
    config: OnChainVerifierConfig
  ): Promise<VerificationResult> {
    const { circuitName, proof, publicInputs, verificationKey } = proofResult;
    const { connection, wallet, verifierProgramId } = config;

    this.logger.info(`Verifying proof on-chain for circuit: ${circuitName}`);
    const startTime = Date.now();

    const programId = verifierProgramId || SUNSPOT_VERIFIER_PROGRAM_ID;

    try {
      // Create the verification instruction
      const instruction = this.createVerifyInstruction(
        programId,
        wallet.publicKey,
        proof,
        publicInputs,
        verificationKey
      );

      // Build and send transaction
      const transaction = new Transaction().add(instruction);

      const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash();
      transaction.recentBlockhash = blockhash;
      transaction.feePayer = wallet.publicKey;

      const signedTx = await wallet.signTransaction(transaction);
      const signature = await connection.sendRawTransaction(signedTx.serialize());

      // Wait for confirmation
      await connection.confirmTransaction(
        { signature, blockhash, lastValidBlockHeight },
        'confirmed'
      );

      const verificationTime = Date.now() - startTime;

      this.logger.info(
        `On-chain verification succeeded for ${circuitName}: ${signature}`
      );

      return {
        valid: true,
        circuitName,
        verificationTimeMs: verificationTime,
        signature,
      };
    } catch (error) {
      const verificationTime = Date.now() - startTime;

      this.logger.error(`On-chain verification failed for ${circuitName}`, error);

      return {
        valid: false,
        circuitName,
        verificationTimeMs: verificationTime,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  /**
   * Create the verification instruction for Sunspot
   */
  private createVerifyInstruction(
    programId: PublicKey,
    payer: PublicKey,
    proof: Uint8Array,
    publicInputs: string[],
    verificationKey: Uint8Array
  ): TransactionInstruction {
    // Encode public inputs as field elements
    const encodedInputs = this.encodePublicInputs(publicInputs);

    // Calculate instruction data size
    // Format: [instruction_type (1), vk_len (4), vk, proof_len (4), proof, inputs_len (4), inputs]
    const dataSize =
      1 + // instruction type
      4 + verificationKey.length + // verification key
      4 + proof.length + // proof
      4 + encodedInputs.length; // public inputs

    const data = Buffer.alloc(dataSize);
    let offset = 0;

    // Instruction type
    data.writeUInt8(SunspotInstruction.VerifyProofInline, offset);
    offset += 1;

    // Verification key
    data.writeUInt32LE(verificationKey.length, offset);
    offset += 4;
    Buffer.from(verificationKey).copy(data, offset);
    offset += verificationKey.length;

    // Proof
    data.writeUInt32LE(proof.length, offset);
    offset += 4;
    Buffer.from(proof).copy(data, offset);
    offset += proof.length;

    // Public inputs
    data.writeUInt32LE(encodedInputs.length, offset);
    offset += 4;
    Buffer.from(encodedInputs).copy(data, offset);

    return new TransactionInstruction({
      programId,
      keys: [
        { pubkey: payer, isSigner: true, isWritable: true },
        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
      ],
      data,
    });
  }

  /**
   * Encode public inputs as bytes for on-chain verification
   */
  private encodePublicInputs(inputs: string[]): Uint8Array {
    // Each input is a 32-byte field element
    const encoded = new Uint8Array(inputs.length * 32);

    for (let i = 0; i < inputs.length; i++) {
      const value = BigInt(inputs[i]);
      const bytes = this.bigIntToBytes32(value);
      encoded.set(bytes, i * 32);
    }

    return encoded;
  }

  /**
   * Convert BigInt to 32-byte array (big-endian)
   */
  private bigIntToBytes32(value: bigint): Uint8Array {
    const bytes = new Uint8Array(32);
    let remaining = value;

    for (let i = 31; i >= 0; i--) {
      bytes[i] = Number(remaining & BigInt(0xff));
      remaining = remaining >> BigInt(8);
    }

    return bytes;
  }

  /**
   * Deploy a verification key on-chain for repeated use
   */
  async deployVerificationKey(
    circuitName: string,
    verificationKey: Uint8Array,
    config: OnChainVerifierConfig
  ): Promise<{ address: PublicKey; signature: string }> {
    const { connection, wallet, verifierProgramId } = config;
    const programId = verifierProgramId || SUNSPOT_VERIFIER_PROGRAM_ID;

    this.logger.info(`Deploying verification key for ${circuitName}`);

    // Generate a PDA for the verification key
    const [vkAccount] = PublicKey.findProgramAddressSync(
      [
        Buffer.from('verification_key'),
        wallet.publicKey.toBuffer(),
        Buffer.from(circuitName),
      ],
      programId
    );

    // Create initialization instruction
    const dataSize = 1 + 4 + verificationKey.length + 32; // instruction + length + vk + circuit name
    const data = Buffer.alloc(dataSize);
    let offset = 0;

    data.writeUInt8(SunspotInstruction.InitVerificationKey, offset);
    offset += 1;

    data.writeUInt32LE(verificationKey.length, offset);
    offset += 4;

    Buffer.from(verificationKey).copy(data, offset);
    offset += verificationKey.length;

    // Circuit name (padded to 32 bytes)
    const nameBuffer = Buffer.alloc(32);
    nameBuffer.write(circuitName);
    nameBuffer.copy(data, offset);

    const instruction = new TransactionInstruction({
      programId,
      keys: [
        { pubkey: wallet.publicKey, isSigner: true, isWritable: true },
        { pubkey: vkAccount, isSigner: false, isWritable: true },
        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
      ],
      data,
    });

    const transaction = new Transaction().add(instruction);
    const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash();
    transaction.recentBlockhash = blockhash;
    transaction.feePayer = wallet.publicKey;

    const signedTx = await wallet.signTransaction(transaction);
    const signature = await connection.sendRawTransaction(signedTx.serialize());

    await connection.confirmTransaction(
      { signature, blockhash, lastValidBlockHeight },
      'confirmed'
    );

    this.logger.info(`Verification key deployed at ${vkAccount.toBase58()}`);

    return {
      address: vkAccount,
      signature,
    };
  }

  /**
   * Verify a proof using a pre-deployed verification key
   */
  async verifyWithDeployedKey(
    proof: Uint8Array,
    publicInputs: string[],
    vkAccount: PublicKey,
    config: OnChainVerifierConfig
  ): Promise<VerificationResult> {
    const { connection, wallet, verifierProgramId } = config;
    const programId = verifierProgramId || SUNSPOT_VERIFIER_PROGRAM_ID;

    const startTime = Date.now();

    try {
      const encodedInputs = this.encodePublicInputs(publicInputs);

      // Build instruction data
      const dataSize = 1 + 4 + proof.length + 4 + encodedInputs.length;
      const data = Buffer.alloc(dataSize);
      let offset = 0;

      data.writeUInt8(SunspotInstruction.VerifyProof, offset);
      offset += 1;

      data.writeUInt32LE(proof.length, offset);
      offset += 4;
      Buffer.from(proof).copy(data, offset);
      offset += proof.length;

      data.writeUInt32LE(encodedInputs.length, offset);
      offset += 4;
      Buffer.from(encodedInputs).copy(data, offset);

      const instruction = new TransactionInstruction({
        programId,
        keys: [
          { pubkey: wallet.publicKey, isSigner: true, isWritable: true },
          { pubkey: vkAccount, isSigner: false, isWritable: false },
          { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
        ],
        data,
      });

      const transaction = new Transaction().add(instruction);
      const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash();
      transaction.recentBlockhash = blockhash;
      transaction.feePayer = wallet.publicKey;

      const signedTx = await wallet.signTransaction(transaction);
      const signature = await connection.sendRawTransaction(signedTx.serialize());

      await connection.confirmTransaction(
        { signature, blockhash, lastValidBlockHeight },
        'confirmed'
      );

      return {
        valid: true,
        circuitName: 'unknown',
        verificationTimeMs: Date.now() - startTime,
        signature,
      };
    } catch (error) {
      return {
        valid: false,
        circuitName: 'unknown',
        verificationTimeMs: Date.now() - startTime,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  /**
   * Cleanup resources
   */
  async destroy(): Promise<void> {
    this.logger.info('Destroying verifier instances');

    for (const [name, backend] of this.backends) {
      try {
        await backend.destroy();
      } catch (error) {
        this.logger.warn(`Failed to destroy backend for ${name}`, error);
      }
    }

    this.backends.clear();
  }
}

/**
 * Utility: Verify a proof without initializing a full verifier
 * Useful for one-off verifications
 */
export async function verifyProofQuick(
  circuit: CompiledCircuit,
  proof: Uint8Array,
  publicInputs: string[]
): Promise<boolean> {
  const backend = new BarretenbergBackend(circuit);

  try {
    const isValid = await backend.verifyProof({ proof, publicInputs });
    return isValid;
  } finally {
    await backend.destroy();
  }
}

/**
 * Default verifier instance
 */
let defaultVerifier: NoirVerifier | null = null;

/**
 * Get the default verifier instance
 */
export function getDefaultVerifier(): NoirVerifier {
  if (!defaultVerifier) {
    defaultVerifier = new NoirVerifier();
  }
  return defaultVerifier;
}

/**
 * Create a new verifier with custom configuration
 */
export function createVerifier(
  compiler?: NoirCompiler,
  logger?: Logger
): NoirVerifier {
  return new NoirVerifier(compiler, logger);
}
